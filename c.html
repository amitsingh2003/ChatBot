<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ROBOTAKSH - Advanced AI Assistant</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --primary: #6c5ce7;
        --secondary: #a363d9;
        --accent: #00ff95;
        --background: #0f172a;
        --card-bg: rgba(255, 255, 255, 0.05);
        --text: #fff;
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        font-family: "Space Grotesk", sans-serif;
      }

      html,
      body {
        height: 100%;
        margin: 0;
        overflow: hidden;
      }

      body {
        background: var(--background);
        color: var(--text);
        display: flex;
        align-items: stretch;
        position: relative;
      }

      /* Animated Background */
      body::before {
        content: "";
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: radial-gradient(
            circle at 20% 20%,
            rgba(108, 92, 231, 0.1) 0%,
            transparent 40%
          ),
          radial-gradient(
            circle at 80% 80%,
            rgba(163, 99, 217, 0.1) 0%,
            transparent 40%
          );
        animation: backgroundPulse 10s ease infinite alternate;
        z-index: -1;
      }

      @keyframes backgroundPulse {
        0% {
          transform: scale(1);
        }
        100% {
          transform: scale(1.1);
        }
      }

      .container {
        flex: 1;
        display: flex;
        flex-direction: column;
        background: rgba(255, 255, 255, 0.03);
        backdrop-filter: blur(10px);
        position: relative;
      }

      /* Animated Border */
      .container::before {
        content: "";
        position: absolute;
        inset: 0;
        border: 2px solid transparent;
        background: linear-gradient(
            45deg,
            var(--primary),
            var(--secondary),
            var(--accent)
          )
          border-box;
        -webkit-mask: linear-gradient(#fff 0 0) padding-box,
          linear-gradient(#fff 0 0);
        -webkit-mask-composite: destination-out;
        mask-composite: exclude;
        animation: borderAnimation 4s linear infinite;
      }

      @keyframes borderAnimation {
        0% {
          background-position: 0% 0%;
        }
        100% {
          background-position: 200% 0%;
        }
      }

      .header {
        background: linear-gradient(135deg, var(--primary), var(--secondary));
        padding: 25px;
        text-align: center;
        position: relative;
        overflow: hidden;
        flex-shrink: 0;
      }

      /* Advanced Header Animation */
      .header::after {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 2px;
        background: var(--accent);
        animation: scanline 2s linear infinite;
      }

      @keyframes scanline {
        0% {
          transform: translateX(-100%);
        }
        100% {
          transform: translateX(100%);
        }
      }

      .header h1 {
        font-size: 2.5em;
        margin-bottom: 15px;
        text-shadow: 0 0 10px rgba(108, 92, 231, 0.5);
        position: relative;
        display: inline-block;
      }

      /* Glitch Effect */
      .header h1::before,
      .header h1::after {
        content: "ROBOTAKSH";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        overflow: hidden;
        background: var(--background);
        color: var(--accent);
      }

      .header h1::before {
        left: 2px;
        text-shadow: -2px 0 red;
        animation: glitch-1 2s infinite linear alternate-reverse;
      }

      .header h1::after {
        left: -2px;
        text-shadow: 2px 0 blue;
        animation: glitch-2 2s infinite linear alternate-reverse;
      }

      @keyframes glitch-1 {
        0% {
          clip-path: inset(20% 0 30% 0);
        }
        20% {
          clip-path: inset(60% 0 10% 0);
        }
        40% {
          clip-path: inset(40% 0 50% 0);
        }
        60% {
          clip-path: inset(80% 0 5% 0);
        }
        80% {
          clip-path: inset(10% 0 70% 0);
        }
        100% {
          clip-path: inset(30% 0 20% 0);
        }
      }

      @keyframes glitch-2 {
        0% {
          clip-path: inset(30% 0 20% 0);
        }
        20% {
          clip-path: inset(10% 0 70% 0);
        }
        40% {
          clip-path: inset(80% 0 5% 0);
        }
        60% {
          clip-path: inset(40% 0 50% 0);
        }
        80% {
          clip-path: inset(60% 0 10% 0);
        }
        100% {
          clip-path: inset(20% 0 30% 0);
        }
      }

      .status {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 12px;
        font-size: 1em;
        position: relative;
      }

      .status-dot {
        width: 12px;
        height: 12px;
        background: var(--accent);
        border-radius: 50%;
        position: relative;
      }

      /* Advanced Status Dot */
      .status-dot::before {
        content: "";
        position: absolute;
        inset: -4px;
        border-radius: 50%;
        background: var(--accent);
        opacity: 0.5;
        animation: ripple 1.5s cubic-bezier(0, 0.2, 0.8, 1) infinite;
      }

      @keyframes ripple {
        0% {
          transform: scale(1);
          opacity: 0.5;
        }
        100% {
          transform: scale(3);
          opacity: 0;
        }
      }

      #chatbox {
        flex: 1;
        overflow-y: auto;
        padding: 25px;
        background: var(--card-bg);
        scroll-behavior: smooth;
        perspective: 1000px;
      }

      #chatbox::-webkit-scrollbar {
        width: 6px;
      }

      #chatbox::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.05);
      }

      #chatbox::-webkit-scrollbar-thumb {
        background: var(--primary);
        border-radius: 3px;
      }

      .message {
        margin: 15px 0;
        padding: 15px 20px;
        border-radius: 20px;
        max-width: 85%;
        position: relative;
        transform-style: preserve-3d;
        transition: transform 0.3s ease;
      }

      .message:hover {
        transform: translateZ(20px);
      }

      .user-message {
        background: linear-gradient(135deg, var(--primary), var(--secondary));
        margin-left: auto;
        border-bottom-right-radius: 5px;
        box-shadow: 0 10px 20px rgba(108, 92, 231, 0.2);
      }

      .bot-message {
        background: var(--card-bg);
        border-bottom-left-radius: 5px;
        box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .input-container {
        padding: 20px;
        background: var(--card-bg);
        display: flex;
        gap: 15px;
        align-items: center;
        border-top: 1px solid rgba(255, 255, 255, 0.1);
        position: relative;
      }

      /* Command Palette */
      .command-palette {
        position: absolute;
        bottom: 100%;
        left: 20px;
        right: 20px;
        background: rgba(15, 23, 42, 0.95);
        border-radius: 10px;
        padding: 15px;
        display: none;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: 0 -10px 30px rgba(0, 0, 0, 0.2);
      }

      .command {
        padding: 10px;
        border-radius: 5px;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .command:hover {
        background: rgba(255, 255, 255, 0.1);
      }

      .command i {
        color: var(--accent);
      }

      #input-box {
        flex: 1;
        padding: 15px 20px;
        border: 2px solid rgba(255, 255, 255, 0.1);
        border-radius: 30px;
        outline: none;
        font-size: 1em;
        background: rgba(255, 255, 255, 0.05);
        color: var(--text);
        transition: all 0.3s ease;
      }

      #input-box:focus {
        border-color: var(--primary);
        box-shadow: 0 0 20px rgba(108, 92, 231, 0.2);
      }

      #input-box::placeholder {
        color: rgba(255, 255, 255, 0.5);
      }

      button {
        padding: 15px 25px;
        border: none;
        border-radius: 30px;
        background: linear-gradient(135deg, var(--primary), var(--secondary));
        color: var(--text);
        cursor: pointer;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        gap: 8px;
        font-weight: 500;
        position: relative;
        overflow: hidden;
      }

      button::before {
        content: "";
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(
          90deg,
          transparent,
          rgba(255, 255, 255, 0.2),
          transparent
        );
        transition: 0.5s;
      }

      button:hover::before {
        left: 100%;
      }

      button i {
        font-size: 1.1em;
      }

      #voice {
        display: none;
        text-align: center;
        padding: 15px 30px;
        color: var(--accent);
        font-weight: 500;
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(15, 23, 42, 0.9);
        backdrop-filter: blur(10px);
        border-radius: 30px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
      }

      .typing-indicator {
        display: none;
        padding: 15px;
        margin: 10px 0;
      }

      .typing-indicator span {
        display: inline-block;
        width: 8px;
        height: 8px;
        background: var(--primary);
        border-radius: 50%;
        margin: 0 3px;
        opacity: 0.4;
      }

      @keyframes blink {
        0%,
        100% {
          opacity: 0.4;
        }
        50% {
          opacity: 1;
        }
      }

      .typing-indicator span:nth-child(1) {
        animation: blink 1s 0.1s infinite;
      }
      .typing-indicator span:nth-child(2) {
        animation: blink 1s 0.2s infinite;
      }
      .typing-indicator span:nth-child(3) {
        animation: blink 1s 0.3s infinite;
      }

      /* Responsive Design */
      @media (max-width: 768px) {
        .header h1 {
          font-size: 2em;
        }

        .input-container {
          padding: 15px;
        }

        button {
          padding: 12px 20px;
        }

        .command-palette {
          display: none !important;
        }
      }

      @media (max-width: 480px) {
        .header h1 {
          font-size: 1.8em;
        }

        .message {
          max-width: 95%;
          font-size: 0.9em;
        }

        button {
          padding: 10px 15px;
          font-size: 0.9em;
        }

        #input-box {
          padding: 12px 15px;
          font-size: 0.9em;
        }

        .input-container {
          flex-wrap: wrap;
        }
      }
      .speech-controls {
        text-align: center;
        margin: 10px 0;
        padding: 10px;
        background: var(--card-bg);
        border-radius: 15px;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .control-button {
        padding: 8px 15px;
        margin: 0 5px;
        border: none;
        border-radius: 20px;
        background: var(--card-bg);
        color: var(--text);
        cursor: pointer;
        transition: all 0.3s ease;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .control-button:hover {
        background: var(--primary);
      }

      .control-button i {
        font-size: 0.9em;
      }

      /* Add responsive styles */
      @media (max-width: 480px) {
        .speech-controls {
          padding: 8px;
        }

        .control-button {
          padding: 6px 12px;
          font-size: 0.9em;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>ROBOTAKSH</h1>
        <div class="status">
          <div class="status-dot"></div>
          <span>AI Assistant Online</span>
        </div>
      </div>

      <div id="chatbox">
        <div class="typing-indicator">
          <span></span>
          <span></span>
          <span></span>
        </div>
        <div class="speech-controls" style="display: none">
          <button id="pause-button" class="control-button">
            <i class="fas fa-pause"></i>
            <span>Pause</span>
          </button>
          <button id="stop-button" class="control-button">
            <i class="fas fa-stop"></i>
            <span>Stop</span>
          </button>
        </div>
      </div>

      <div class="input-container">
        <div class="command-palette">
          <div class="command">
            <i class="fas fa-wand-magic-sparkles"></i>
            <span>/help - Show available commands</span>
          </div>
          <div class="command">
            <i class="fas fa-broom"></i>
            <span>/clear - Clear chat history</span>
          </div>
          <div class="command">
            <i class="fas fa-code"></i>
            <span>/code - Format as code</span>
          </div>
        </div>
        <input type="<!-- Previous CSS and HTML remains the same until input container -->
        <input
          type="text"
          id="input-box"
          placeholder="Type '/' for commands or your message..."
        />
        <button id="send-button">
          <i class="fas fa-paper-plane"></i>
          Send
        </button>
        <button id="btn">
          <i class="fas fa-microphone"></i>
          Speak
        </button>
      </div>
    </div>

    <div id="voice">Listening...</div>

    <script>
      const chatbox = document.getElementById("chatbox");
      const inputBox = document.getElementById("input-box");
      const sendButton = document.getElementById("send-button");
      const btn = document.querySelector("#btn");
      const voice = document.querySelector("#voice");
      const typingIndicator = document.querySelector(".typing-indicator");
      const commandPalette = document.querySelector(".command-palette");
      const speechControls = document.querySelector(".speech-controls");
      const pauseButton = document.getElementById("pause-button");
      const stopButton = document.getElementById("stop-button");
      let isCodeMode = false;

      // Command palette toggle
      inputBox.addEventListener("input", (e) => {
        if (e.target.value === "/") {
          commandPalette.style.display = "block";
        } else {
          commandPalette.style.display = "none";
        }
      });

      // Handle command clicks
      document.querySelectorAll(".command").forEach((cmd) => {
        cmd.addEventListener("click", () => {
          const command = cmd.querySelector("span").textContent.split(" - ")[0];
          inputBox.value = command + " ";
          commandPalette.style.display = "none";
          inputBox.focus();
        });
      });

      // Show typing indicator
      function showTyping() {
        typingIndicator.style.display = "block";
        chatbox.scrollTop = chatbox.scrollHeight;
      }

      // Hide typing indicator
      function hideTyping() {
        typingIndicator.style.display = "none";
      }

      // Enhanced message display with animations
      function addMessage(message, isUser) {
        const messageDiv = document.createElement("div");
        messageDiv.className = `message ${
          isUser ? "user-message" : "bot-message"
        }`;

        const time = new Date().toLocaleTimeString([], {
          hour: "2-digit",
          minute: "2-digit",
        });

        // Format code blocks if present
        const formattedMessage = message.replace(
          /```(\w+)?\n([\s\S]+?)\n```/g,
          (match, lang, code) => `
            <pre style="background: rgba(0,0,0,0.2); padding: 10px; border-radius: 5px; overflow-x: auto;">
              <code>${code.trim()}</code>
            </pre>
          `
        );

        messageDiv.innerHTML = `
          ${formattedMessage}
          <div style="font-size: 0.8em; margin-top: 5px; opacity: 0.7;">${time}</div>
        `;

        messageDiv.style.opacity = "0";
        messageDiv.style.transform = "translateY(20px)";

        chatbox.insertBefore(messageDiv, typingIndicator);

        // Trigger animation
        requestAnimationFrame(() => {
          messageDiv.style.transition = "all 0.3s ease";
          messageDiv.style.opacity = "1";
          messageDiv.style.transform = "translateY(0)";
        });

        chatbox.scrollTop = chatbox.scrollHeight;
      }

      // Enhanced backend interaction with error handling
      async function sendToBackend(message) {
        showTyping();
        try {
          const response = await fetch("http://localhost:5000/api/chat", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ prompt: message }),
          });

          if (!response.ok) {
            throw new Error("Server response was not ok");
          }

          const data = await response.json();
          hideTyping();
          return data.response;
        } catch (error) {
          console.error("Error:", error);
          hideTyping();
          return "I apologize, but I'm having trouble connecting to the server. Please try again later.";
        }
      }

      // Enhanced speech synthesis with voice selection
      function speak(text) {
        if (speechSynthesis.speaking) {
          speechSynthesis.cancel();
        }

        let utterance = new SpeechSynthesisUtterance(text);
        utterance.rate = 1.1;
        utterance.pitch = 1;
        utterance.volume = 1;
        utterance.lang = "en-US";

        // Wait for voices to load
        window.speechSynthesis.onvoiceschanged = () => {
          const voices = window.speechSynthesis.getVoices();
          const preferredVoice = voices.find(
            (voice) =>
              voice.name.includes("Google") || voice.name.includes("Female")
          );

          if (preferredVoice) {
            utterance.voice = preferredVoice;
          }
        };

        window.speechSynthesis.speak(utterance);
      }

      // Enhanced greeting with time-based messages
      function wishMe() {
        const hour = new Date().getHours();
        let greeting;

        if (hour < 12) {
          greeting = "Good morning! How can I assist you today?";
        } else if (hour < 16) {
          greeting = "Good afternoon! What can I help you with?";
        } else if (hour < 20) {
          greeting = "Good evening! How may I be of service?";
        } else {
          greeting = "Hello! How can I help you tonight?";
        }

        speak(greeting);
        addMessage(greeting, false);
      }

      // Initialize
      window.addEventListener("load", () => {
        wishMe();
        inputBox.focus();
      });

      // Enhanced speech recognition with feedback
      let recognition = new (window.SpeechRecognition ||
        window.webkitSpeechRecognition)();
      recognition.continuous = false;
      recognition.lang = "en-US";

      recognition.onstart = () => {
        voice.style.display = "block";
        btn.style.backgroundColor = "#a363d9";
      };

      recognition.onend = () => {
        voice.style.display = "none";
        btn.style.backgroundColor = "#6c5ce7";
      };

      recognition.onresult = async (event) => {
        const transcript = event.results[0][0].transcript;
        inputBox.value = transcript;
        addMessage(transcript, true);
        await processMessage(transcript.toLowerCase());
      };

      recognition.onerror = (event) => {
        console.error("Speech recognition error:", event.error);
        voice.textContent = "Error - Please try again";
        setTimeout(() => {
          voice.style.display = "none";
          voice.textContent = "Listening...";
        }, 2000);
      };

      // Enhanced message processing with commands
      async function processMessage(message) {
        let response;

        // Handle commands
        if (message.startsWith("/clear")) {
          chatbox.innerHTML = "";
          response = "Chat history cleared!";
        } else if (message.startsWith("/help")) {
          response = `Available commands:
          /help - Show this help message
          /clear - Clear chat history
          /code - Format next message as code`;
        } else {
          response = await sendToBackend(message);
        }

        speak(response);
        addMessage(response, false);
      }

      // Event listeners
      btn.addEventListener("click", () => recognition.start());

      sendButton.addEventListener("click", async () => {
        const message = inputBox.value.trim();
        if (!message) return;

        addMessage(message, true);
        inputBox.value = "";
        await processMessage(message);
      });

      inputBox.addEventListener("keypress", async (e) => {
        if (e.key === "Enter") {
          const message = inputBox.value.trim();
          if (!message) return;

          addMessage(message, true);
          inputBox.value = "";
          await processMessage(message);
        }
      });

      // Add some visual feedback on input focus
      inputBox.addEventListener("focus", () => {
        inputBox.style.boxShadow = "0 0 20px rgba(108, 92, 231, 0.3)";
      });

      inputBox.addEventListener("blur", () => {
        inputBox.style.boxShadow = "none";
      });

      let isSpeaking = false;
      let isPaused = false;
      let currentUtterance = null;

      // Modify your existing speak function
      function speak(text) {
        if (speechSynthesis.speaking) {
          speechSynthesis.cancel();
        }

        currentUtterance = new SpeechSynthesisUtterance(text);
        currentUtterance.rate = 1.1;
        currentUtterance.pitch = 1;
        currentUtterance.volume = 1;
        currentUtterance.lang = "en-US";

        // Show speech controls when speaking starts
        speechControls.style.display = "block";
        isSpeaking = true;
        isPaused = false;

        // Handle speech end
        currentUtterance.onend = () => {
          isSpeaking = false;
          speechControls.style.display = "none";
          pauseButton.innerHTML =
            '<i class="fas fa-pause"></i> <span>Pause</span>';
        };

        // Wait for voices to load
        window.speechSynthesis.onvoiceschanged = () => {
          const voices = window.speechSynthesis.getVoices();
          const preferredVoice = voices.find(
            (voice) =>
              voice.name.includes("Google") || voice.name.includes("Female")
          );

          if (preferredVoice) {
            currentUtterance.voice = preferredVoice;
          }
        };

        window.speechSynthesis.speak(currentUtterance);
      }

      // Add pause/resume functionality
      pauseButton.addEventListener("click", () => {
        if (!isSpeaking) return;

        if (isPaused) {
          speechSynthesis.resume();
          pauseButton.innerHTML =
            '<i class="fas fa-pause"></i> <span>Pause</span>';
          isPaused = false;
        } else {
          speechSynthesis.pause();
          pauseButton.innerHTML =
            '<i class="fas fa-play"></i> <span>Resume</span>';
          isPaused = true;
        }
      });

      // Add stop functionality
      stopButton.addEventListener("click", () => {
        if (!isSpeaking) return;

        speechSynthesis.cancel();
        isSpeaking = false;
        isPaused = false;
        speechControls.style.display = "none";
        pauseButton.innerHTML =
          '<i class="fas fa-pause"></i> <span>Pause</span>';
      });

      // Modify your processMessage function to handle stopping
      let isProcessing = false;

      async function processMessage(message) {
        if (isProcessing) {
          return; // Prevent multiple simultaneous processes
        }

        isProcessing = true;
        let response;

        try {
          // Handle commands
          if (message.startsWith("/clear")) {
            chatbox.innerHTML = "";
            response = "Chat history cleared!";
          } else if (message.startsWith("/help")) {
            response = `Available commands:
      /help - Show this help message
      /clear - Clear chat history
      /code - Format next message as code`;
          } else {
            response = await sendToBackend(message);
          }

          speak(response);
          addMessage(response, false);
        } finally {
          isProcessing = false;
        }
      }

      async function processMessage(message) {
        if (isProcessing) {
          return;
        }

        isProcessing = true;
        let response;

        try {
          // Handle commands
          if (message.startsWith("/clear")) {
            chatbox.innerHTML = "";
            response = "Chat history cleared!";
            isCodeMode = false; // Reset code mode when clearing
          } else if (message.startsWith("/help")) {
            response = `Available commands:
      /help - Show this help message
      /clear - Clear chat history
      /code - Format next message as code`;
          } else if (message.startsWith("/code")) {
            isCodeMode = true;
            response =
              "Code formatting enabled. Your next message will be formatted as code.";
          } else {
            // If code mode is enabled, format the message as code
            if (isCodeMode) {
              addMessage("```\n" + message + "\n```", true);
              isCodeMode = false; // Reset code mode after using it
            } else {
              addMessage(message, true);
            }
            response = await sendToBackend(message);
          }

          speak(response);
          addMessage(response, false);
        } finally {
          isProcessing = false;
        }
      }

      // Enhance the addMessage function to better handle code formatting
      function addMessage(message, isUser) {
        const messageDiv = document.createElement("div");
        messageDiv.className = `message ${
          isUser ? "user-message" : "bot-message"
        }`;

        const time = new Date().toLocaleTimeString([], {
          hour: "2-digit",
          minute: "2-digit",
        });

        // Enhanced code block formatting
        const formattedMessage = message.replace(
          /```(\w+)?\n?([\s\S]+?)\n?```/g,
          (match, lang, code) => `
      <pre style="
        background: rgba(0,0,0,0.3);
        padding: 15px;
        border-radius: 8px;
        overflow-x: auto;
        font-family: monospace;
        font-size: 0.9em;
        margin: 10px 0;
        border: 1px solid rgba(255,255,255,0.1);
      ">
        <code>${code.trim()}</code>
      </pre>
    `
        );

        messageDiv.innerHTML = `
    ${formattedMessage}
    <div style="font-size: 0.8em; margin-top: 5px; opacity: 0.7;">${time}</div>
  `;

        messageDiv.style.opacity = "0";
        messageDiv.style.transform = "translateY(20px)";

        chatbox.insertBefore(messageDiv, typingIndicator);

        requestAnimationFrame(() => {
          messageDiv.style.transition = "all 0.3s ease";
          messageDiv.style.opacity = "1";
          messageDiv.style.transform = "translateY(0)";
        });

        chatbox.scrollTop = chatbox.scrollHeight;
      }
    </script>
  </body>
</html>
